/*
 * Copyright 2011 Mark McKay
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * FBOTestPanel.java
 *
 * Created on Jun 30, 2011, 5:33:39 PM
 */
package com.kitfox.fbotest;

import com.jogamp.common.nio.Buffers;
import com.jogamp.opengl.util.Animator;
import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import javax.media.opengl.GL;
import javax.media.opengl.GL2;
import javax.media.opengl.GLAutoDrawable;
import javax.media.opengl.GLEventListener;
import javax.media.opengl.awt.GLJPanel;

/**
 *
 * @author kitfox
 */
public class FBOTestPanel 
    extends GLJPanel
//    extends GLCanvas
//    extends GLWindow
        implements GLEventListener
{
    Animator animator;
    Font font;

    int viewWidth;
    int viewHeight;
    int curFrame;

    public int[] texIds = new int[10];


    static final int tileSize = 32;

    static final boolean useFBObuffer = false;
    private int bufferId;
    private int colorBufferTexId;
    private int depthBufferId;

    /** Creates new form FBOTestPanel */
    public FBOTestPanel()
    {
        initComponents();

        font = new Font(Font.SANS_SERIF, Font.PLAIN, 20);

        addGLEventListener(this);
    }

    private ByteBuffer allocateByte(int size)
    {
        return Buffers.newDirectByteBuffer(size);
        
//        ByteBuffer bb = ByteBuffer.allocateDirect(size);
//        bb.order(ByteOrder.nativeOrder());
//        return bb;
    }

    public static IntBuffer allocateInt(int size)
    {
        return Buffers.newDirectIntBuffer(size);
        
//        ByteBuffer bb = ByteBuffer.allocateDirect(size * 4);
//        bb.order(ByteOrder.nativeOrder());
//        return bb.asIntBuffer();
    }

    private int createTileTex(GL2 gl, String text)
    {
        BufferedImage img = new BufferedImage(tileSize, tileSize, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = img.createGraphics();

        g.setColor(Color.red);
        g.setFont(font);
        FontMetrics fm = g.getFontMetrics();
        Rectangle2D rect = fm.getStringBounds(text, g);
//        g.translate(-rect.getX(), -rect.getY());
        g.drawString(text, (float)-rect.getX(), (float)-rect.getY());

        g.dispose();
//try
//{
//    ImageIO.write(img, "png", new File("img.png"));
//} catch (IOException ex)
//{
//    Logger.getLogger(FBOTestPanel.class.getName()).log(Level.SEVERE, null, ex);
//}

        return getDefineTexture(gl, img);
    }

    public int getDefineTexture(GL2 gl, BufferedImage img)
    {
        ByteBuffer buf = allocateByte(img.getWidth() * img.getHeight() * 4);
        for (int j = img.getHeight() - 1; j >= 0; --j)
        {
            for (int i = 0; i < img.getWidth(); ++i)
            {
                int argb = img.getRGB(i, j);

                buf.put((byte)((argb >> 16) & 0xff));
                buf.put((byte)((argb >> 8) & 0xff));
                buf.put((byte)((argb) & 0xff));
                buf.put((byte)((argb >> 24) & 0xff));
            }
        }
        buf.rewind();

        IntBuffer ibuf = allocateInt(1);
        gl.glGenTextures(1, ibuf);
        int id = ibuf.get(0);

        gl.glBindTexture(GL.GL_TEXTURE_2D, id);
        gl.glTexImage2D(GL.GL_TEXTURE_2D,
                0, GL.GL_RGBA, img.getWidth(), img.getHeight(), 0,
                GL.GL_RGBA, GL.GL_UNSIGNED_BYTE,
                buf);
        gl.glTexParameterf(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP_TO_EDGE);
        gl.glTexParameterf(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP_TO_EDGE);
        gl.glTexParameterf(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MAG_FILTER,
            GL.GL_NEAREST);
        gl.glTexParameterf(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MIN_FILTER,
            GL.GL_NEAREST);

        return id;
        //return buf;
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
    }// </editor-fold>//GEN-END:initComponents

    public void init(GLAutoDrawable glad)
    {
        GL2 gl = glad.getGL().getGL2();

        for (int i = 0; i < texIds.length; ++i)
        {
            texIds[i] = createTileTex(gl, "" + i);
        }

        if (animator != null)
        {
            animator.remove(glad);
            animator.stop();
            animator = null;
        }

        animator = new Animator();
        animator.add(glad);
        animator.start();
    }

    public void display(GLAutoDrawable glad)
    {
        GL2 gl = glad.getGL().getGL2();

        if (useFBObuffer)
        {
            if (bufferId == 0)
            {
                IntBuffer ibuf = allocateInt(1);

                gl.glGenFramebuffers(1, ibuf);
                bufferId = ibuf.get(0);

                gl.glBindFramebuffer(GL.GL_FRAMEBUFFER, bufferId);

                {
                    gl.glGenTextures(1, ibuf);
                    colorBufferTexId = ibuf.get(0);

                    gl.glBindTexture(GL.GL_TEXTURE_2D, colorBufferTexId);
                    gl.glTexParameterf(GL.GL_TEXTURE_2D,
                            GL.GL_TEXTURE_MIN_FILTER, GL.GL_LINEAR);
                    gl.glTexParameterf(GL.GL_TEXTURE_2D,
                            GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR);
                    gl.glTexParameterf(GL.GL_TEXTURE_2D,
                            GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP_TO_EDGE);
                    gl.glTexParameterf(GL.GL_TEXTURE_2D,
                            GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP_TO_EDGE);
                    gl.glGenerateMipmap(GL.GL_TEXTURE_2D);

                    gl.glTexImage2D(GL.GL_TEXTURE_2D,
                            0, GL.GL_RGBA, viewWidth, viewHeight, 0,
                            GL.GL_RGBA, GL.GL_UNSIGNED_BYTE, null);

                    gl.glFramebufferTexture2D(GL.GL_FRAMEBUFFER, GL.GL_COLOR_ATTACHMENT0,
                            GL.GL_TEXTURE_2D, colorBufferTexId, 0);
                }

                {
                    gl.glGenRenderbuffers(1, ibuf);
                    depthBufferId = ibuf.get(0);

                    gl.glBindRenderbuffer(GL2.GL_RENDERBUFFER, depthBufferId);
                    gl.glRenderbufferStorage(GL2.GL_RENDERBUFFER, GL2.GL_DEPTH_COMPONENT16,
                            viewWidth, viewHeight);

                    gl.glFramebufferRenderbuffer(GL.GL_FRAMEBUFFER, GL.GL_DEPTH_ATTACHMENT,
                            GL.GL_RENDERBUFFER, depthBufferId);
                    
                }

                int status = gl.glCheckFramebufferStatus(GL2.GL_FRAMEBUFFER);
                if (status != GL2.GL_FRAMEBUFFER_COMPLETE)
                {
                    throw new RuntimeException("Framebuffer incomplete: " + status);
                }

                gl.glViewport(0, 0, viewWidth, viewHeight);
            }
            else
            {
                gl.glBindFramebuffer(GL.GL_FRAMEBUFFER, bufferId);
                gl.glViewport(0, 0, viewWidth, viewHeight);
            }
//            System.err.println("FBO!");
        }


        gl.glClearColor(1, 1, 1, 1);
        gl.glClear(GL.GL_COLOR_BUFFER_BIT |
                GL.GL_DEPTH_BUFFER_BIT | GL.GL_STENCIL_BUFFER_BIT);

        int numCol = (viewWidth - 1) / tileSize + 1;
        int numRow = (viewHeight - 1) / tileSize + 1;

        ++curFrame;
        int tileIdx = curFrame % texIds.length;

        gl.glEnable(GL.GL_TEXTURE_2D);
//        gl.glShadeModel(GL.GL_FLAT);
        gl.glEnable(GL.GL_BLEND);
        gl.glBlendFunc(GL.GL_SRC_ALPHA, GL.GL_ONE_MINUS_SRC_ALPHA);

        for (int j = 0; j < numRow; ++j)
        {
            for (int i = 0; i < numCol; ++i)
            {
                int x0 = i * tileSize;
                int x1 = x0 + tileSize;
                int y0 = j * tileSize;
                int y1 = y0 + tileSize;

                gl.glBindTexture(GL.GL_TEXTURE_2D, texIds[tileIdx]);

                {
                    gl.glBegin(GL2.GL_QUADS);
                    
                    gl.glTexCoord2d(0.0, 0.0); gl.glVertex2d(x0, y0);
                    gl.glTexCoord2d(1.0, 0.0); gl.glVertex2d(x1, y0);
                    gl.glTexCoord2d(1.0, 1.0); gl.glVertex2d(x1, y1);
                    gl.glTexCoord2d(0.0, 1.0); gl.glVertex2d(x0, y1);

                    gl.glEnd();
                }
            }
        }


        if (useFBObuffer)
        {
                //Blit tile to screen
            gl.glBindFramebuffer(GL.GL_FRAMEBUFFER, 0);
            gl.glViewport(0, 0, viewWidth, viewHeight);

            gl.glBindTexture(GL.GL_TEXTURE_2D, colorBufferTexId);

            {
                gl.glBegin(GL2.GL_QUADS);

                gl.glTexCoord2d(0.0, 0.0); gl.glVertex2d(0, 0);
                gl.glTexCoord2d(1.0, 0.0); gl.glVertex2d(viewWidth, 0);
                gl.glTexCoord2d(1.0, 1.0); gl.glVertex2d(viewWidth, viewHeight);
                gl.glTexCoord2d(0.0, 1.0); gl.glVertex2d(0, viewHeight);

                gl.glEnd();
            }
        }

//        System.err.println("Disp");
    }

    public void reshape(GLAutoDrawable glad, int x, int y, int width, int height)
    {
        GL2 gl = glad.getGL().getGL2();
        gl.glViewport(x, y, width, height);

        gl.glMatrixMode(GL2.GL_PROJECTION);
        gl.glLoadIdentity();
        gl.glOrtho(0, width, 0, height, -1, 1);
        gl.glMatrixMode(GL2.GL_MODELVIEW);

        viewWidth = width;
        viewHeight = height;

        if (useFBObuffer)
        {
            if (bufferId != 0)
            {
                IntBuffer ibuf = allocateInt(1);

                ibuf.put(0, bufferId);
                gl.glDeleteFramebuffers(1, ibuf);
                bufferId = 0;

                ibuf.put(0, colorBufferTexId);
                gl.glDeleteTextures(1, ibuf);
                colorBufferTexId = 0;

                ibuf.put(0, depthBufferId);
                gl.glDeleteRenderbuffers(1, ibuf);
                depthBufferId = 0;
            }

        }
    }

    public void dispose(GLAutoDrawable glad)
    {
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
