/*
 * Copyright 2011 Mark McKay
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * CoyotePanel.java
 *
 * Created on May 23, 2011, 11:15:55 AM
 */
package com.kitfox.coyote.renderer.jogl;

import com.jogamp.opengl.util.Animator;
import com.kitfox.coyote.drawRecord.CyDrawGroupZOrder;
import com.kitfox.coyote.math.CyMatrix4d;
import com.kitfox.coyote.renderer.CyDrawStack;
import com.kitfox.coyote.renderer.CyFramebuffer;
import com.kitfox.coyote.renderer.CyFramebufferRenderbuffer;
import com.kitfox.coyote.renderer.CyFramebufferTexture;
import com.kitfox.coyote.renderer.CyRendererListener;
import com.kitfox.coyote.renderer.CyRendererUtil2D;
import com.kitfox.coyote.renderer.CyGLContext;
import com.kitfox.coyote.renderer.CyGLWrapper.Attachment;
import com.kitfox.coyote.renderer.CyGLWrapper.DataType;
import com.kitfox.coyote.renderer.CyGLWrapper.InternalFormatBuf;
import com.kitfox.coyote.renderer.CyGLWrapper.InternalFormatTex;
import com.kitfox.coyote.renderer.CyGLWrapper.TexTarget;
import java.util.ArrayList;
import javax.media.opengl.DebugGL2;
import javax.media.opengl.GL;
import javax.media.opengl.GLAutoDrawable;
import javax.media.opengl.GLCapabilities;
import javax.media.opengl.GLEventListener;
import javax.media.opengl.GLProfile;
import javax.media.opengl.awt.GLJPanel;

/**
 *
 * @author kitfox
 */
public class CoyotePanel extends GLJPanel
//public class CoyotePanel extends GLCanvas
        implements GLEventListener
{
    int tileWidth = 256;
    int tileHeight = 256;

    int deviceWidth;
    int deviceHeight;

    CyFramebuffer tileBuffer;
    CyFramebufferTexture colorBuf;
    CyFramebufferRenderbuffer depthBuf;

    ArrayList<CyRendererListener> listeners =
            new ArrayList<CyRendererListener>();

//    CyRenderTileCache tileCache = new CyRenderTileCache();

    //Drawing tools
//    CyVertexBuffer vbufSquare;
//    CyMaterialTextureBlit tileMaterial;
    int surfaceInstance;

    long startTime;
    int curPass;

    Animator animator;
    CyGLContext glContext;

    static final boolean useFBObuffer = false;

    /** Creates new form CoyotePanel */
    public CoyotePanel()
    {
//        super();
        super(getCapabilities());

//        initComponents();
        addGLEventListener(this);

//        vbufSquare = new CyVertexBuffer(CyVertexBufferDataSquare.inst());
//        tileMaterial = new CyMaterialTextureBlit();

    }

    private static GLCapabilities getCapabilities()
    {
        GLProfile glprofile = GLProfile.getDefault();
        GLCapabilities cap = new GLCapabilities(glprofile);

//        cap.setAlphaBits(8);
        cap.setHardwareAccelerated(true);
//        cap.setSampleBuffers(true);
//        cap.setNumSamples(8);

        return cap;
    }

    public void addCyRendererListener(CyRendererListener l)
    {
        listeners.add(l);
    }

    public void removeCyRendererListener(CyRendererListener l)
    {
        listeners.remove(l);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
    }// </editor-fold>//GEN-END:initComponents

    public void setTileSize(int tileWidth, int tileHeight)
    {
        this.tileWidth = tileWidth;
        this.tileHeight = tileHeight;

//        if (tileBuffer != null)
//        {
//            tileBuffer.dispose();
//        }

        tileBuffer = null;
        colorBuf = null;
        depthBuf = null;
    }

    @Override
    public void init(GLAutoDrawable drawable)
    {
        //Debug
        drawable.setGL(new DebugGL2(drawable.getGL().getGL2()));

        startTime = System.currentTimeMillis();

        GL gl = drawable.getGL();
        System.err.println("Initializing GL Thread (" + surfaceInstance + ")");
//        System.err.println(gl.glGetString(GL.GL_EXTENSIONS));
        System.err.println("GL version:" + gl.glGetString(GL.GL_VERSION));

        //Each time init() is called, the context has been recreated.
        glContext = new CyGLContext();

        ++surfaceInstance;
        // Enable VSync
//        gl.setSwapInterval(1);

        if (animator != null)
        {
            animator.remove(drawable);
            animator.stop();
            animator = null;
        }

        animator = new Animator(drawable);
//        animator.add(drawable);
//        animator.setRunAsFastAsPossible(true);

        animator.start();
    }

    @Override
    public void display(GLAutoDrawable drawable)
    {
//        debugBuffer(drawable.getGL());

//        drawable.getContext().
//        GLWrapperJOGL gl = new GLWrapperJOGL(drawable, surfaceInstance);
        CyGLWrapperJOGL gl = new CyGLWrapperJOGL(drawable);
        //GLActionQueue.inst().processActions(gl);
        glContext.processActions(gl);

        ++curPass;
        long curTime = System.currentTimeMillis();

        //Write everything to tile
        CyDrawGroupZOrder drawGroup = new CyDrawGroupZOrder();
        CyDrawStack rend = new CyDrawStack(
                deviceWidth, deviceHeight,
//                0, 0,
//                startTime, curTime, curPass,
                drawGroup);

        //Still need to blit to tile back buffer for speed
        //Speed work around for JOGL 1.1.1
        if (useFBObuffer)
        {
            if (tileBuffer == null)
            {
                colorBuf = new CyFramebufferTexture(Attachment.GL_COLOR_ATTACHMENT0,
                        TexTarget.GL_TEXTURE_2D, InternalFormatTex.GL_RGBA,
                        DataType.GL_UNSIGNED_BYTE, tileWidth, tileHeight);
                depthBuf = new CyFramebufferRenderbuffer(Attachment.GL_DEPTH_ATTACHMENT,
                        tileWidth, tileHeight, InternalFormatBuf.GL_DEPTH_COMPONENT16);
                tileBuffer = new CyFramebuffer(tileWidth, tileHeight, colorBuf, depthBuf);
            }
            tileBuffer.bind(glContext, gl);
//            System.err.println("FBO!");
        }


        for (int k = 0; k < listeners.size(); ++k)
        {
            listeners.get(k).render(rend);
        }

        drawGroup.render(glContext, gl, null);
        drawGroup.dispose();

        //Speed work around for JOGL 1.1.1
        if (useFBObuffer)
        {
                //Blit tile to screen
                gl.glBindFramebuffer(0);
                gl.glViewport(0, 0, deviceWidth, deviceHeight);
//colorBuf.bind(gl);
//colorBuf.dumpTexture(gl, new File("buffer.png"), "png");
        CyMatrix4d tileXform = CyMatrix4d.createIdentity();

        double tileSpanW = 2 * tileWidth / (double)deviceWidth;
        double tileSpanH = 2 * tileHeight / (double)deviceHeight;
        tileXform.m00 = tileSpanW;
        tileXform.m11 = tileSpanH;
            tileXform.m13 = tileSpanH * 0 - 1;
                tileXform.m03 = tileSpanW * 0 - 1;

                CyRendererUtil2D.drawTileImage(glContext, gl, colorBuf,
                        tileXform);
        }

    }

//    @Override
//    public void display(GLAutoDrawable drawable)
//    {
////        debugBuffer(drawable.getGL());
//
////        drawable.getContext().
//        GLWrapperJOGL gl = new GLWrapperJOGL(drawable, surfaceInstance);
//        GLActionQueue.inst().processActions(gl);
//
//        ++curPass;
//        long curTime = System.currentTimeMillis();
//        System.err.println(curTime);

//        if (tileBuffer == null)
//        {
//            colorBuf = new CyFramebufferTexture(Attachment.GL_COLOR_ATTACHMENT0,
//                    TexTarget.GL_TEXTURE_2D, InternalFormatTex.GL_RGBA,
//                    DataType.GL_UNSIGNED_BYTE, tileWidth, tileHeight);
//            depthBuf = new CyFramebufferRenderbuffer(Attachment.GL_DEPTH_ATTACHMENT,
//                    tileWidth, tileHeight, InternalFormatBuf.GL_DEPTH_COMPONENT16);
//            tileBuffer = new CyFramebuffer(tileWidth, tileHeight, colorBuf, depthBuf);
//        }
//
//        int numCol = (viewportWidth - 1) / tileWidth + 1;
//        int numRow = (viewportHeight - 1) / tileHeight + 1;
//
//        CyMatrix4d tileXform = CyMatrix4d.createIdentity();
//
//        double tileSpanW = 2 * tileWidth / (double)viewportWidth;
//        double tileSpanH = 2 * tileHeight / (double)viewportHeight;
//        tileXform.m00 = tileSpanW;
//        tileXform.m11 = tileSpanH;
//
////numRow = numCol = 1;
//
//        for (int j = 0; j < numRow; ++j)
//        {
//            int y = j * tileHeight;
//
//            tileXform.m13 = tileSpanH * j - 1;
//
//            for (int i = 0; i < numCol; ++i)
//            {
//                int x = i * tileWidth;
//
//                tileXform.m03 = tileSpanW * i - 1;
//
//                //Write everything to tile
//                CyDrawStack rend = new CyDrawStack(gl,
//                        tileCache,
//                        viewportWidth, viewportHeight,
//                        new CyRectangle2i(x, y, tileWidth, tileHeight),
//                        tileBuffer,
//                        startTime, curTime, curPass);
//
//                for (int k = 0; k < listeners.size(); ++k)
//                {
//                    listeners.get(k).render(rend);
//                }
//
//                //Blit tile to screen
//                gl.glBindFramebuffer(0);
//                gl.glViewport(0, 0, viewportWidth, viewportHeight);
////colorBuf.bind(gl);
////colorBuf.dumpTexture(gl, new File("buffer.png"), "png");
//                tileMaterial.setTexture(colorBuf);
//
//                tileMaterial.setMvpMatrix(tileXform);
//                tileMaterial.bind(gl);
//                tileMaterial.draw(gl, CyVertexBufferDataSquare.inst().getBuffer());
//
////                int m = 9;
//            }
//        }
//    }

    @Override
    public void reshape(GLAutoDrawable drawable, int x, int y, int width, int height)
    {
        deviceWidth = width;
        deviceHeight = height;

        GL gl = drawable.getGL();
        gl.glViewport(x, y, width, height);

        setTileSize(deviceWidth, deviceHeight);

        //Calc projection matrix
//        Matrix4f proj = new Matrix4f();
//        if (height <= 0)
//        {
//            height = 1;
//        }
//        final float scrnAspect = (float)width / height;
//        MatrixUtil.frustumPersp(proj, fovY, scrnAspect * aspect, nearPlane, farPlane);
//        cube.setViewerProjMtx(proj);
    }

    @Override
    public void dispose(GLAutoDrawable glad)
    {
    }

//    @Override
//    public void displayChanged(GLAutoDrawable drawable, boolean modeChanged, boolean deviceChanged)
//    {
//    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
